## URL Override Library
#
# This should probably be turned into a service, but so far it's just a library used by the Browser Service.

fs   = require 'fs'
Path = require 'path'
Url  = require 'url'
# debug = require('debug')('livereload:urloverride')

ERR_NOT_MATCHED    = 'not-matched'
ERR_FILE_NOT_FOUND = 'file-not-found'
ERR_AUTH_FAILED    = 'auth-failed'


class FileType
  constructor: ->
    @overridable = no
    @mime = "application/octet-stream"

class CSSFileType
  constructor: ->
    @overridable = yes
    @mime = "text/css"
    @isCSS = yes

class ImageFileType
  constructor: (@mime) ->
    @overridable = yes

FileTypeByExtension =
  '.css':  new CSSFileType()
  '.png':  new ImageFileType('image/png')
  '.jpg':  new ImageFileType('image/jpg')
  '.jpeg': new ImageFileType('image/jpg')
  '.gif':  new ImageFileType('image/gif')

lookupFileType = (path) ->
  ext = Path.extname(path)
  FileTypeByExtension[ext] ? new FileType()


CSS_IMPORT_RE = ///
  # capture 1: before file name
  (
    url    \s*
    \(     \s*?
    ['"]?
  )
  # capture 2: file name
  (
    [^)'"]*
  )
  # capture 3: after file name
  (
    ['"]?  \s*?
    \)
  )
///g


class URLOverrideCoordinator

  constructor: ->
    @authenticator = new PathAuthenticator()
    @fs   = require('fs')
    @Path = require('path')

  shouldOverrideFile: (path) ->
    lookupFileType(path).overridable

  createOverrideURL: (path) ->
    @authenticator.urlPathForServingLocalPath(path)

  handleHttpRequest: (url, callback) ->
    [errCode, localPath] = @authenticator.localPathForUrlPath(url.pathname)

    return callback(ERR_NOT_MATCHED)    if errCode is 404
    return callback(ERR_AUTH_FAILED)    if errCode is 403
    return callback(errCode)            if errCode isnt 200

    await @Path.exists(localPath, defer exists)
    return callback(ERR_FILE_NOT_FOUND) unless exists

    baseUrl  = url.query?.url
    fileType = lookupFileType(localPath)

    if fileType.isCSS && baseUrl
      await @fs.readFile(localPath, 'utf8', defer(err, content))
      return callback(err) if err

      content = content.replace CSS_IMPORT_RE, (match, prefix, importedURL, suffix) ->
        newURL = Url.resolve(baseUrl, importedURL)
        "#{prefix}#{newURL}#{suffix}"

      content = new Buffer(content)

    else
      await @fs.readFile(localPath, 'utf8', defer(err, content))
      return callback(err) if err

    return callback(null, { mime: fileType.mime, content })


module.exports = { URLOverrideCoordinator, ERR_NOT_MATCHED, ERR_AUTH_FAILED, ERR_FILE_NOT_FOUND }


## PathAuthenticator

crypto = require 'crypto'

random8  = -> Math.random().toString(36).substr(2,8)
random40 = -> random8() + random8() + random8() + random8() + random8()


class PathAuthenticator

  constructor: ->
    @salt = random40()

  sign: (localPath) ->
    crypto.createHmac('sha1', @salt).update(localPath).digest('hex')

  urlPathForServingLocalPath: (localPath) ->
    if localPath.length == 0 or localPath[0] != '/'
      throw new Error("urlPathForServingLocalPath: localPath is expected to start with a slash: '#{localPath}'")

    signature = @sign(localPath)
    # debug "urlPathForServingLocalPath: localPath = #{localPath}"
    return  "/_livereload/url-override-v1/#{signature}#{localPath}"

  localPathForUrlPath: (urlPath) ->
    if m = urlPath.match ///^ /_livereload/url-override-v1/ ([a-z0-9]{40}) (/.*) $///
      [_, signature, localPath] = m
      localPath = decodeURI(localPath)
      # debug "localPathForUrlPath: localPath = #{localPath}"
      if @sign(localPath) == signature
        return [200, localPath]
      else
        return [403]
    return [404]
