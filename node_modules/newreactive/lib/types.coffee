
class ArrayType
  isTypeDescriptor: yes

  constructor: (@elemType) ->

  toString: ->
    "{ array: #{@elemType} }"

  defaultValue: -> []

  coerce: (value) ->
    unless Array.isArray(value)
      throw new Error("Value is not an array: " + JSON.stringify(value))
    if @elemType is StdTypes.any
      value.slice(0)
    else
      (@elemType.coerce(elem) for elem in value)

  resolve: (resolver, context) ->
    new ArrayType(@elemType.resolve(resolver, context))


class ObjectType
  isTypeDescriptor: yes

  constructor: (@class) ->
    if !@class.name then throw new Error "Only classes with a .name can be used for type checking"

  toString: ->
    "{ object: #{@class.name} }"

  coerce: (value) ->
    if value?
      unless typeof value is 'object'
        throw new Error "Invalid #{typeof value} value, expected #{@class.name}"
      unless value instanceof @class
        throw new Error "Invalid #{value.constructor.name or 'object'} value, expected #{@class.name}"
    value

  defaultValue: -> null  # TODO: deal with nullability

  resolve: (resolver, context) -> this


class UnresolvedClassReferenceType
  isTypeDescriptor: yes

  constructor: (@name) ->

  toString: ->
    @name

  resolve: (resolver, context) ->
    resolver.resolveClassReference(@name, context)

  coerce: (value) ->
    throw new Error "Trying to use UnresolvedClassReferenceType(#{this})"

  defaultValue: ->
    throw new Error "Trying to use UnresolvedClassReferenceType(#{this})"


StdTypes =
  any:
    isTypeDescriptor: yes
    coerce: (value) ->
      value
    toString: ->
      'any'
    defaultValue: -> null
    resolve: (resolver, context) -> this

  string:
    isTypeDescriptor: yes
    coerce: (value) ->
      if value?
        "#{value}"
      else
        null
    toString: ->
      'string'
    defaultValue: -> ''
    resolve: (resolver, context) -> this

  int:
    isTypeDescriptor: yes
    coerce: (value) ->
      switch typeof value
        when 'number', 'string' then ~~value
        else throw new Error "Invalid type #{typeof value}, expected an integer"
    toString: ->
      'int'
    defaultValue: -> 0
    resolve: (resolver, context) -> this

  number:
    isTypeDescriptor: yes
    coerce: (value) ->
      +value
    toString: ->
      'number'
    defaultValue: -> 0
    resolve: (resolver, context) -> this

  boolean:
    isTypeDescriptor: yes
    coerce: (value) ->
      !!value
    toString: ->
      'boolean'
    defaultValue: -> no
    resolve: (resolver, context) -> this

StdTypes.array = new ArrayType(StdTypes.any)


exports.resolve = resolve = (type, resolver) ->
  if resolver
    result = resolve(type)
    while result.resolve
      result = result.resolve(resolver)
    return result

  if !type?
    StdTypes.any
  else if type.isTypeDescriptor
    type
  else
    switch typeof type
      when 'string'
        if type.substr(0, 1) == type.substr(0, 1).toUpperCase()
          new UnresolvedClassReferenceType(type)
        else
          StdTypes[type] or throw new Error "Unknown type name #{type}"
      when 'object'
        if type.constructor is Object
          keys = Object.keys(type)
          if (keys.length is 1) and (keys[0] is 'array')
            new ArrayType(resolve(type.array))
          else if (keys.length is 1) and (keys[0] is 'object')
            new ObjectType(type.object)
          else
            throw new Error "Unsupported type declaration #{type}"
        else
          throw new Error "Unsupported type declaration #{type}"
      when 'function'
        if type is String
          StdTypes.string
        else if type is Array
          StdTypes.array
        else if type is Boolean
          StdTypes.boolean
        else if type is Number
          StdTypes.number
        else if type is Object
          StdTypes.any
        else
          new ObjectType(type)


exports.coerce = (value, type) ->
  resolve(type).coerce(value)
